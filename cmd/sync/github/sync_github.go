/*
Copyright Â© 2023 maxgio92 me@maxgio.me

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package github

import (
	"fmt"
	"io"
	"net/url"
	"os"
	"path"
	"time"

	"github.com/go-git/go-git/v5"
	gitplumbing "github.com/go-git/go-git/v5/plumbing"
	gitobject "github.com/go-git/go-git/v5/plumbing/object"
	githttp "github.com/go-git/go-git/v5/plumbing/transport/http"
	"github.com/google/uuid"
	"github.com/pkg/errors"
	"github.com/spf13/cobra"
	"golang.org/x/exp/maps"
	peribolos "k8s.io/test-infra/prow/config/org"
	"k8s.io/test-infra/prow/github"
	"k8s.io/test-infra/prow/repoowners"
	"sigs.k8s.io/yaml"

	syncergithub "github.com/maxgio92/peribolos-owners-syncer/pkg/github"
	"github.com/maxgio92/peribolos-owners-syncer/pkg/orgs"
	"github.com/maxgio92/peribolos-owners-syncer/pkg/owners"
	"github.com/maxgio92/peribolos-owners-syncer/pkg/sync"
)

type options struct {
	*sync.Options

	author gitobject.Signature
	github syncergithub.GitHubOptions
	orgs   *orgs.PeribolosOptions
	owners *owners.OwnersOptions
}

const (
	syncerSignature = "Autogenerated with [orgs-owners-syncer](https://github.com/maxgio92/orgs-owners-syncer)."
	ownersDoc       = "https://docs.prow.k8s.io/docs/components/plugins/approve/approvers/#overview"
)

// New returns a new sync github command.
// TODO: generate doc.
func New() *cobra.Command {
	o := &options{
		Options: &sync.Options{},
		author:  gitobject.Signature{},
		github:  syncergithub.GitHubOptions{},
		owners:  &owners.OwnersOptions{},
		orgs:    &orgs.PeribolosOptions{},
	}

	cmd := &cobra.Command{
		Use:   "github",
		Short: "Synchronize Peribolos org.yaml file from OWNERS file on remote github repositories via Pull Request",
		RunE:  o.Run,
	}

	// Organization sync options.
	cmd.Flags().StringVar(&o.GitHubOrg, "org", "", "The name of the GitHub organization to update configuration for")
	cmd.Flags().StringVar(&o.GitHubTeam, "team", "", "The name of the GitHub team to update configuration for")

	// Git options.
	cmd.Flags().StringVar(&o.author.Name, "git-author-name", "", "The Git author name with which write commits for the update of the Peribolos config")
	cmd.Flags().StringVar(&o.author.Email, "git-author-email", "", "The Git author email with which write commits for the update of the Peribolos config")

	// GitHub options.
	o.github.AddPFlags(cmd.Flags())

	// Owners options.
	o.owners.AddPFlags(cmd.Flags())

	// Orgs config options.
	o.orgs.AddPFlags(cmd.Flags())

	return cmd
}

func (o *options) validate() error {
	if o.GitHubOrg == "" {
		return fmt.Errorf("github organization name is empty")
	}

	if o.GitHubTeam == "" {
		return fmt.Errorf("github team name is empty")
	}

	if o.author.Name == "" {
		return fmt.Errorf("git author name is empty")
	}

	if o.author.Email == "" {
		return fmt.Errorf("git author email is empty")
	}

	if err := o.owners.Validate(); err != nil {
		return err
	}

	if err := o.orgs.Validate(); err != nil {
		return err
	}

	if err := o.github.ValidateAll(); err != nil {
		return err
	}

	return nil
}

func (o *options) Run(cmd *cobra.Command, args []string) error {
	if err := o.validate(); err != nil {
		return err
	}

	// Get the GitHub token from filesystem.
	token, err := os.ReadFile(o.github.TokenPath)
	if err != nil {
		return errors.Wrap(err, "error reading token file")
	}

	// Build GitHub client.
	gh, err := o.github.GitHubClientWithAccessToken(string(token))
	if err != nil {
		return errors.Wrap(err, "error generating GitHub client with specified access token")
	}

	// Load Owners hierarchy from specified repository.
	owners, err := o.loadOwners(gh)
	if err != nil {
		return errors.Wrap(err, "error loading owners from repository")
	}

	// Get the leaf approvers from the Owners hierarchy.
	approvers := maps.Keys(owners.LeafApprovers(o.owners.OwnersPath))

	// TODO: fork the Peribolos config repository.

	// Clone orgs config repository.
	repo, worktree, tmp, err := o.cloneOrgsConfigRepo(string(token))
	if err != nil {
		return err
	}

	// Build Peribolos config.
	orgsConfig, err := o.loadOrgsConfig(worktree)
	if err != nil {
		return err
	}

	// Create an ephemeral branch for the changes.
	ref, err := o.newEphemeralGitBranch(repo, worktree)
	if err != nil {
		return nil
	}

	// Synchronize the Github Team config with Approvers.
	if err = o.updateTeams(orgsConfig, approvers, tmp); err != nil {
		return err
	}

	// Create a commit with all staged changes to the new branch.
	if err = o.commitAll(repo, worktree); err != nil {
		return err
	}

	if !o.github.DryRun {

		// Push the new branch to the remote with the user access token.
		if err := repo.Push(&git.PushOptions{
			Auth: &githttp.BasicAuth{
				Username: o.github.Username,
				Password: string(token),
			},
		}); err != nil {
			return errors.Wrap(err, "error pushing orgs config update git branch")
		}

		// Create a Pull Request on GitHub.
		pr, err := o.createPullRequest(gh, ref)
		if err != nil {
			return err
		}

		fmt.Printf("A Pull Request has been opened: https://%s/%s/%s/pull/%d", o.github.Host, o.GitHubOrg, o.orgs.ConfigRepo, *pr)
	}

	return nil
}

func (o *options) loadOwners(githubClient github.Client) (repoowners.RepoOwner, error) {
	gitClientFactory, err := o.github.GetGitClientFactory()
	if err != nil {
		return nil, errors.Wrap(err, "error building git client factory")
	}

	ownersClient, err := o.owners.BuildClient(githubClient, gitClientFactory)
	if err != nil {
		return nil, errors.Wrap(err, "error building owners client")
	}

	owners, err := ownersClient.LoadRepoOwners(o.GitHubOrg, o.owners.OwnersRepo, o.owners.OwnersBaseRef)
	if err != nil {
		return nil, errors.Wrap(err, "error loading owners")
	}

	return owners, nil
}

func (o *options) loadOrgsConfig(worktree *git.Worktree) (*peribolos.FullConfig, error) {
	r, err := worktree.Filesystem.Open(o.orgs.ConfigPath)
	if err != nil {
		return nil, errors.Wrap(err, "error opening orgs config file")
	}

	b, err := io.ReadAll(r)
	if err != nil {
		return nil, errors.Wrap(err, "error reading Peribolos config file")
	}

	config := orgs.NewConfig()

	if err = yaml.Unmarshal(b, config); err != nil {
		return nil, errors.Wrap(err, "error unmarshaling Peribolos config")
	}

	return config, nil
}

func (o *options) cloneOrgsConfigRepo(githubToken string) (*git.Repository, *git.Worktree, string, error) {
	tmp, err := os.MkdirTemp("", "orgs")
	if err != nil {
		return nil, nil, "", errors.Wrap(err, "error creating temporary direcotry for cloning git repo")
	}

	orgsRepoURL, err := url.JoinPath(fmt.Sprintf("https://%s", o.github.Host), o.GitHubOrg, o.orgs.ConfigRepo)
	if err != nil {
		return nil, nil, "", errors.Wrap(err, "error generating Peribolos config repository URL")
	}

	repo, err := git.PlainClone(tmp, false, &git.CloneOptions{
		Auth: &githttp.BasicAuth{
			Username: o.github.Username, // yes, this can be anything except an empty string
			Password: githubToken,
		},
		URL:      orgsRepoURL,
		Progress: nil,
	})
	if err != nil {
		return nil, nil, "", errors.Wrap(err, "error cloning git repository")
	}

	worktree, err := repo.Worktree()
	if err != nil {
		return nil, nil, "", errors.Wrap(err, "error getting repository worktree")
	}

	return repo, worktree, tmp, nil
}

func (o *options) newEphemeralGitBranch(repo *git.Repository, worktree *git.Worktree) (string, error) {
	id := uuid.New()
	refName := id.String()
	headRef, err := repo.Head()
	if err != nil {
		return "", errors.Wrap(err, "error getting repository HEAD reference")
	}

	ref := gitplumbing.NewHashReference(
		gitplumbing.NewBranchReferenceName(refName),
		headRef.Hash(),
	)
	err = repo.Storer.SetReference(ref)

	if err = worktree.Checkout(&git.CheckoutOptions{
		Branch: gitplumbing.NewBranchReferenceName(refName),
	}); err != nil {
		return "", errors.Wrap(err, "error checking out just created branch")
	}

	return refName, nil
}

func (o *options) updateTeams(orgsConfig *peribolos.FullConfig, approvers []string, wPath string) error {
	if err := orgs.UpdateTeamMembers(orgsConfig, o.GitHubOrg, o.GitHubTeam, approvers); err != nil {
		return errors.Wrap(err, "error updating Peribolos' maintainers from OWNERS's approvers")
	}

	// Write the update Peribolos config file.
	b, err := yaml.Marshal(orgsConfig)
	if err != nil {
		return errors.Wrap(err, "error recompiling the Peribolos config")
	}

	if err = os.WriteFile(path.Join(wPath, o.orgs.ConfigPath), b, 0644); err != nil {
		return errors.Wrap(err, "error writing the recompiled Peribolos config")
	}

	return nil
}

func (o *options) commitAll(repo *git.Repository, worktree *git.Worktree) error {
	// Stage the updated Peribolos config file to the index.
	if _, err := worktree.Add(o.orgs.ConfigPath); err != nil {
		return errors.Wrap(err, "error staging Peribolos config file")
	}

	// Store the change in a commitAll with a log.
	commitMsg := fmt.Sprintf(`chore(org.yaml): update %s team members

The update reflects the content of the related repository root's OWNERS.
%s

Signed-off-by: %s <%s>
`, o.GitHubTeam, syncerSignature, o.author.Name, o.author.Email)
	commit, err := worktree.Commit(commitMsg, &git.CommitOptions{
		Author: &gitobject.Signature{
			Name:  o.author.Name,
			Email: o.author.Email,
			When:  time.Now(),
		},
	})
	if err != nil {
		return errors.Wrap(err, "error creating orgs config update git commitAll")
	}

	// Create a commitAll.
	_, err = repo.CommitObject(commit)
	if err != nil {
		return errors.Wrap(err, "error retrieving the orgs config update commitAll hash")
	}

	return nil
}

func (o *options) createPullRequest(gh github.Client, ref string) (*int, error) {
	n, err := gh.CreatePullRequest(
		o.GitHubOrg,
		o.orgs.ConfigRepo,
		fmt.Sprintf("Sync Github Team %s with %s owners", o.GitHubTeam, o.owners.OwnersRepo),
		fmt.Sprintf(`This PR synchronizes the Github Team %s with the leaf approvers declared in %s repository's [OWNERS](%s) file.

%s
`, o.GitHubTeam, o.owners.OwnersRepo, ownersDoc, syncerSignature),
		ref,
		o.orgs.ConfigBaseRef,
		false,
	)
	if err != nil {
		return nil, errors.Wrap(err, "error creating GitHub Pull Request")
	}

	return &n, nil
}
